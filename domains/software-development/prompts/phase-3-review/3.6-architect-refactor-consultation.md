# Prompt: Architect Refactoring Consultation

**Persona:** Solutions Architect
**Phase:** 3 - Review and Refactoring
**Purpose:** Analyze refactoring options and trade-offs

---

## When to Use This Prompt

✅ **Use when:**
- Code works but needs improvement
- You want to explore refactoring options
- You need to understand trade-offs between approaches
- You're deciding between multiple solutions

❌ **Don't use when:**
- You know exactly what refactoring to do (just do it)
- Code has bugs (fix bugs first)
- You want new features (use Phase 1 planning)

---

## The Most Advanced Technique: Trade-Off Analysis

This is the most valuable prompt in the entire framework. Instead of asking "refactor this," you ask the Architect to:
1. Propose multiple approaches
2. Analyze the trade-offs of each
3. Recommend when to use each

This prevents naive refactorings that optimize one dimension (e.g., performance) while sacrificing another (e.g., readability).

---

## The Prompt Template

```markdown
You are a Senior Solutions Architect acting as my consultant.

**Code for Refactoring:**
[Paste the function or code segment]

**My Primary Goal:**
My main priority for this refactor is **[performance / readability / maintainability / testability / scalability]**.

**Context:**
[Optional: Explain the context, usage patterns, constraints]
Example: "This function runs 10,000 times per request"
Example: "This code will be maintained by junior developers"

**Your Task:**
Generate **3 potential refactoring strategies** for this code. For each strategy, provide:

1. **Strategy Name:** [e.g., "Strategy A: Extract Service Layer"]

2. **Refactored Code:** [The actual code after refactoring]

3. **Reasoning (Chain-of-Thought):**
   Explain *why* this works and what principles it applies, step-by-step.
   What design patterns or best practices does this use?

4. **Trade-off Analysis:**
   - **Gains:** What does this strategy improve?
   - **Sacrifices:** What does this strategy make worse?
   - **Comparison:** How does it compare to the current code?

   Example trade-offs to consider:
   - Performance vs. Readability
   - Simplicity vs. Flexibility
   - Maintainability vs. Complexity
   - Memory vs. Speed

5. **When to Use This Strategy:**
   Under what conditions is this the best choice?

**Recommendation:**
Based on my stated priority **[repeat the goal]**, which strategy do you recommend and why?

---

**Files to Attach:**
- Code to refactor
- CONSTITUTION.md (for constraints)
- (Optional) Context files
```

---

## Example Input

```python
**Code for Refactoring:**
```python
def process_orders(user_id):
    orders = []
    for order_id in db.get_order_ids(user_id):
        order = db.get_order(order_id)  # N+1 query problem!
        order['items'] = []
        for item_id in db.get_order_item_ids(order_id):
            item = db.get_item(item_id)  # N+1 query problem!
            order['items'].append(item)
        orders.append(order)
    return orders
```

**My Primary Goal:** Performance (this runs on every page load for dashboard)

**Context:** ~50 orders per user, ~10 items per order on average
```

---

## Example Output (What the Architect Should Generate)

```markdown
I've identified 3 refactoring strategies for your order processing code.

---

## Strategy A: Database Query Optimization (JOIN-based)

**Refactored Code:**
```python
def process_orders(user_id):
    # Single query with JOINs - eliminates N+1 problem
    query = """
        SELECT
            o.id as order_id, o.created_at, o.total,
            i.id as item_id, i.name, i.price, i.quantity
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        LEFT JOIN items i ON oi.item_id = i.id
        WHERE o.user_id = ?
        ORDER BY o.id, i.id
    """
    rows = db.query(query, (user_id,))

    # Group results into nested structure
    orders = {}
    for row in rows:
        order_id = row['order_id']
        if order_id not in orders:
            orders[order_id] = {
                'id': order_id,
                'created_at': row['created_at'],
                'total': row['total'],
                'items': []
            }
        if row['item_id']:
            orders[order_id]['items'].append({
                'id': row['item_id'],
                'name': row['name'],
                'price': row['price'],
                'quantity': row['quantity']
            })

    return list(orders.values())
```

**Reasoning:**
This uses a single SQL JOIN to fetch all data at once, eliminating the N+1 query problem. The database does the work of combining orders and items, then we reshape the flat result set into the nested structure.

**Trade-off Analysis:**
- ✅ **Gains:**
  - Massive performance improvement (1 query instead of ~550 queries)
  - Reduced database load
  - Scales well (O(1) queries regardless of order/item count)

- ❌ **Sacrifices:**
  - More complex code (JOIN + grouping logic)
  - Harder to understand for junior developers
  - Less flexible (changes require modifying SQL)
  - Returns all columns (can't easily exclude fields)

**When to Use:**
- Performance is critical
- Data volume is large
- Database round-trips are expensive
- Team is comfortable with SQL

---

## Strategy B: Eager Loading with ORM

**Refactored Code:**
```python
def process_orders(user_id):
    # Using ORM eager loading (example: SQLAlchemy)
    orders = (
        db.query(Order)
        .filter(Order.user_id == user_id)
        .options(joinedload(Order.items))  # Eager load items
        .all()
    )

    return [order.to_dict() for order in orders]
```

**Reasoning:**
This uses the ORM's built-in eager loading to fetch orders and items in a single query (or minimal queries), while keeping the code simple and Pythonic.

**Trade-off Analysis:**
- ✅ **Gains:**
  - Much simpler code (ORM handles complexity)
  - Easy to maintain
  - Type-safe (if using typed ORM models)
  - Flexible (easy to add/remove fields)

- ❌ **Sacrifices:**
  - Slightly slower than raw SQL (ORM overhead)
  - Requires ORM (adds dependency)
  - Less control over exact SQL generated

**When to Use:**
- Already using an ORM
- Code simplicity is important
- Team is not SQL-expert
- Maintainability > raw performance

---

## Strategy C: Caching Layer

**Refactored Code:**
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_order_with_items(order_id):
    order = db.get_order(order_id)
    order['items'] = [
        db.get_item(item_id)
        for item_id in db.get_order_item_ids(order_id)
    ]
    return order

def process_orders(user_id):
    order_ids = db.get_order_ids(user_id)
    return [get_order_with_items(order_id) for order_id in order_ids]
```

**Reasoning:**
This adds caching to minimize database hits for frequently accessed orders. First call is slow (same N+1 problem), but subsequent calls are instant.

**Trade-off Analysis:**
- ✅ **Gains:**
  - Extremely fast for repeat accesses
  - Minimal code changes
  - Easy to implement

- ❌ **Sacrifices:**
  - First access still slow (N+1 problem persists)
  - Cache invalidation complexity
  - Memory overhead (cached data)
  - Stale data risk (if orders update frequently)

**When to Use:**
- Orders are accessed multiple times
- Data doesn't change often
- Memory is available
- Acceptable for first access to be slow

---

## Recommendation

**Given your priority (Performance on every page load):**

I recommend **Strategy A (Database Query Optimization)**.

**Why:**
- You said this runs on every page load (fresh data needed, so caching won't help)
- With ~50 orders × ~10 items = ~500 queries in current code, this is a massive bottleneck
- Strategy A reduces this to 1 query - a 99.8% reduction in database load
- The code complexity is manageable and well-documented

**Implementation notes:**
- Add indexes on `orders.user_id`, `order_items.order_id`, `order_items.item_id`
- Consider adding a `created_at` index if you need to filter recent orders
- Test with realistic data volumes (50+ orders)

**If you decide the SQL is too complex:**
Use Strategy B (ORM eager loading) as a compromise. It's 80% of the performance gain with 20% of the complexity.
```

---

## Tips for Better Consultations

### ✅ DO:
- Clearly state your primary goal
- Provide context (usage patterns, constraints)
- Consider all trade-offs before deciding
- Test the chosen strategy with realistic data

### ❌ DON'T:
- Ask for "the best" refactoring (there's always trade-offs)
- Optimize without measuring first
- Refactor working code without a clear goal
- Ignore the "sacrifices" in the trade-off analysis

---

## Related Resources

- [Solutions Architect Persona](../../personas/02-solutions-architect.md)
- Previous: [Testability](./3.5-qa-testability.md)
- Next: [Documentation](../phase-4-documentation/4.1-readme-generator.md)
